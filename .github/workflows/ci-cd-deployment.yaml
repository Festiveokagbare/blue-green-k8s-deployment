name: CI/CD Blue-Green Deployment

on:
  push:
    branches:
      - main
      - 'release/*'
  workflow_dispatch:

env:
  APP_NAME: blue-green-app
  NAMESPACE: default
  GREEN_LABEL: green
  BLUE_LABEL: blue

jobs:

  # ========================================================================
  # BUILD AND SCAN (unchanged from your version)
  # ========================================================================
  build-and-scan:
    runs-on: ubuntu-latest
    outputs:
      blue_image: ${{ steps.push-blue.outputs.image }}
      green_image: ${{ steps.push-green.outputs.image }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Bandit & deps
        run: |
          pip install --upgrade pip
          pip install bandit
          if [ -f app/blue/requirements.txt ]; then pip install -r app/blue/requirements.txt; fi
          if [ -f app/green/requirements.txt ]; then pip install -r app/green/requirements.txt; fi

      - name: Run Bandit Scan
        run: |
          bandit -r app/blue -ll || true
          bandit -r app/green -ll || true

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1
        with:
          region: us-east-1
        env:
          AWS_REGION: us-east-1
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Build & Push BLUE image
        id: push-blue
        uses: docker/build-push-action@v5
        with:
          context: ./app/blue
          file: ./app/blue/Dockerfile
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BLUE }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BLUE }}:prod

      - name: Build & Push GREEN image
        id: push-green
        uses: docker/build-push-action@v5
        with:
          context: ./app/green
          file: ./app/green/Dockerfile
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_GREEN }}:${{ github.sha }}
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_GREEN }}:prod

      - name: Trivy Scan (BLUE image)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BLUE }}:${{ github.sha }}
          format: table
          exit-code: '1'
          severity: CRITICAL,HIGH

      - name: Trivy Scan (GREEN image)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_GREEN }}:${{ github.sha }}
          format: table
          exit-code: '1'
          severity: CRITICAL,HIGH

  # ========================================================================
  # DEPLOY, VERIFY, FLIP, AUTO-ROLLBACK
  # ========================================================================
  deploy-and-release:
    needs: build-and-scan
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/release/')
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      NAMESPACE: blue-green-app  # Changed from default to dedicated namespace
      APP_NAME: blue-green-app
      GREEN_LABEL: green
      BLUE_LABEL: blue

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # --------------------------
      # INSTALL AND CONFIGURE TOOLS
      # --------------------------
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client

      # Install AWS EKS IAM Authenticator
      - name: Install AWS CLI + EKS IAM Authenticator
        run: |
          echo "Installing AWS CLI v2..."

          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install --update

          aws --version

          echo "Installing aws-iam-authenticator..."
          curl -o aws-iam-authenticator \
            https://amazon-eks.s3.us-west-2.amazonaws.com/1.27.1/2023-04-19/bin/linux/amd64/aws-iam-authenticator

          chmod +x aws-iam-authenticator
          sudo mv aws-iam-authenticator /usr/local/bin/

          aws-iam-authenticator version

      # --------------------------
      # SETUP CLUSTER (bg-eks)
      # --------------------------
      - name: Set cluster name
        run: |
          echo "CLUSTER_NAME=bg-eks" >> $GITHUB_ENV
          echo "Using cluster: bg-eks"

      - name: Generate kubeconfig for EKS
        run: |
          echo "Generating kubeconfig for cluster: $CLUSTER_NAME in region: $AWS_REGION"

          aws eks update-kubeconfig \
            --name "$CLUSTER_NAME" \
            --region "$AWS_REGION" \
            --kubeconfig "$HOME/kubeconfig"

          echo "KUBECONFIG=$HOME/kubeconfig" >> $GITHUB_ENV

          CONTEXT_NAME=$(kubectl config get-contexts -o name --kubeconfig=$HOME/kubeconfig)
          kubectl config use-context "$CONTEXT_NAME" --kubeconfig=$HOME/kubeconfig

          echo "Testing AWS token..."
          aws eks get-token --cluster-name "$CLUSTER_NAME" --region "$AWS_REGION" > /dev/null

          echo "Kubeconfig and authentication ready."

      - name: Verify cluster connection
        run: |
          export AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          export AWS_DEFAULT_REGION=${{ secrets.AWS_REGION }}
          export KUBECONFIG=$HOME/kubeconfig

          echo "Testing connection to cluster..."
          kubectl cluster-info
          kubectl get nodes
          echo "âœ“ Cluster connection successful"
          
      # --------------------------
      # PREPARE NAMESPACE AND CHECK EXISTING DEPLOYMENTS
      # --------------------------
      - name: Ensure namespace exists
        run: |
          kubectl get namespace $NAMESPACE || kubectl create namespace $NAMESPACE
          kubectl config set-context --current --namespace=$NAMESPACE

      - name: Check existing deployments
        run: |
          echo "=== Current deployments in $NAMESPACE ==="
          kubectl get deployments -n $NAMESPACE --show-labels || echo "No deployments found"

          echo ""
          echo "=== Current services in $NAMESPACE ==="
          kubectl get services -n $NAMESPACE || echo "No services found"

          echo ""
          echo "=== Current pods in $NAMESPACE ==="
          kubectl get pods -n $NAMESPACE || echo "No pods found"

      # --------------------------
      # DEPLOY/UPDATE BLUE (INITIAL DEPLOYMENT OR FALLBACK)
      # --------------------------
      - name: Check if service exists
        id: check-service
        run: |
          if kubectl get service app-service -n $NAMESPACE &>/dev/null; then
            echo "Service exists"
            echo "service_exists=true" >> $GITHUB_OUTPUT
            CURRENT_SELECTOR=$(kubectl get service app-service -n $NAMESPACE -o jsonpath='{.spec.selector.version}')
            echo "Current selector: $CURRENT_SELECTOR"
            echo "current_selector=$CURRENT_SELECTOR" >> $GITHUB_OUTPUT
          else
            echo "Service does not exist"
            echo "service_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy BLUE (initial or update)
        if: steps.check-service.outputs.service_exists == 'false' || steps.check-service.outputs.current_selector == 'blue'
        env:
          BLUE_IMAGE: ${{ secrets.REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/blue-app:${{ github.sha }}
        run: |
          echo "Deploying/Updating BLUE version with image: $BLUE_IMAGE"

          # Create or update blue deployment
          sed -e "s|<BLUE_IMAGE>|${BLUE_IMAGE}|g" \
            -e "s|<APP_NAME>|${APP_NAME}|g" \
            -e "s|<BLUE_LABEL>|${BLUE_LABEL}|g" \
            -e "s|<NAMESPACE>|${NAMESPACE}|g" \
            k8s/deployments/blue-deployment.yaml | kubectl apply -f -

          echo "Waiting for BLUE rollout..."
          kubectl rollout status deployment/app-blue \
            --namespace=$NAMESPACE \
            --timeout=180s

          # Create service if it doesn't exist
          if ! kubectl get service app-service -n $NAMESPACE &>/dev/null; then
            echo "Creating service pointing to BLUE..."
            kubectl apply -f k8s/service.yaml -n $NAMESPACE
            sleep 5
          fi

      # --------------------------
      # DEPLOY GREEN (NEW VERSION)
      # --------------------------
      - name: Deploy GREEN version
        env:
          GREEN_IMAGE: ${{ secrets.REGISTRY }}/${{ secrets.IMAGE_NAMESPACE }}/green-app:${{ github.sha }}
        run: |
          echo "Deploying GREEN version with image: $GREEN_IMAGE"

          # Create or update green deployment
          sed -e "s|<GREEN_IMAGE>|${GREEN_IMAGE}|g" \
            -e "s|<APP_NAME>|${APP_NAME}|g" \
            -e "s|<GREEN_LABEL>|${GREEN_LABEL}|g" \
            -e "s|<NAMESPACE>|${NAMESPACE}|g" \
            k8s/deployments/green-deployment.yaml | kubectl apply -f -

      - name: Wait for GREEN rollout
        id: green-rollout
        run: |
          echo "Waiting for GREEN deployment rollout..."
          kubectl rollout status deployment/app-green \
            --namespace=$NAMESPACE \
            --timeout=180s

          echo "GREEN deployment is ready"
          # Record the rollout time
          echo "rollout_time=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      # --------------------------
      # SMOKE TEST GREEN
      # --------------------------
      - name: Smoke test GREEN pod
        id: smoketest
        run: |
          echo "Starting smoke test for GREEN pods..."

          # Wait for pods to be ready
          sleep 10

          # Get GREEN pod
          POD=$(kubectl get pods -n $NAMESPACE \
            -l app=$APP_NAME,version=$GREEN_LABEL \
            --field-selector=status.phase=Running \
            -o jsonpath="{.items[0].metadata.name}" 2>/dev/null || true)

          if [ -z "$POD" ]; then
            echo "ERROR: No running GREEN pod found"
            kubectl get pods -n $NAMESPACE -l app=$APP_NAME,version=$GREEN_LABEL
            exit 1
          fi

          echo "Testing GREEN pod: $POD"

          # Test the pod health with retries
          for i in {1..12}; do
            echo "Health check attempt $i/12..."
            if kubectl exec -n $NAMESPACE $POD -- \
              sh -c 'wget -qO- http://localhost:5000/health && echo " - Healthy"' 2>/dev/null; then
              echo "âœ“ GREEN pod health check passed"
              exit 0
            fi
            sleep 10
          done

          echo "ERROR: GREEN pod health check failed after 2 minutes"
          exit 1

      # --------------------------
      # FLIP SERVICE TO GREEN
      # --------------------------
      - name: Flip service to GREEN
        id: flip-to-green
        run: |
          echo "Switching service to GREEN version..."

          # Patch the service selector
          kubectl patch service app-service -n $NAMESPACE \
            -p '{"spec":{"selector":{"version":"green"}}}'

          echo "Service updated to select GREEN pods"

          # Verify the service selector
          CURRENT_SELECTOR=$(kubectl get service app-service -n $NAMESPACE -o jsonpath='{.spec.selector.version}')
          echo "Current service selector: $CURRENT_SELECTOR"

          if [ "$CURRENT_SELECTOR" != "green" ]; then
            echo "ERROR: Service selector not updated to 'green'"
            exit 1
          fi

      # --------------------------
      # VERIFY GREEN SERVICE
      # --------------------------
      - name: Verify GREEN service
        id: verify-green
        run: |
          echo "Verifying GREEN service is responding..."

          # Get service details
          SERVICE_IP=$(kubectl get service app-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")

          if [ -n "$SERVICE_IP" ]; then
            echo "Service external endpoint: $SERVICE_IP"
          else
            echo "Service is likely ClusterIP type, testing internally..."
          fi

          # Test service internally via a pod
          for i in {1..10}; do
            echo "Service test attempt $i/10..."

            # Get a pod to test from (use green pod)
            TEST_POD=$(kubectl get pods -n $NAMESPACE \
              -l app=$APP_NAME,version=$GREEN_LABEL \
              --field-selector=status.phase=Running \
              -o jsonpath="{.items[0].metadata.name}" 2>/dev/null)

            if [ -n "$TEST_POD" ]; then
              if kubectl exec -n $NAMESPACE $TEST_POD -- \
                timeout 5 sh -c 'wget -qO- http://app-service.'$NAMESPACE'.svc.cluster.local:5000/health' 2>/dev/null; then
                echo "âœ“ GREEN service is responding correctly"
                exit 0
              fi
            fi
            sleep 6
          done

          echo "WARNING: Service verification had issues but continuing..."
          # Don't fail here as the service might be internal only

      # --------------------------
      # CLEAN UP OLD BLUE DEPLOYMENT
      # --------------------------
      - name: Scale down BLUE deployment
        if: success()
        run: |
          echo "Scaling down old BLUE deployment..."

          # Scale down blue deployment
          kubectl scale deployment app-blue --replicas=0 -n $NAMESPACE

          echo "BLUE deployment scaled to 0 replicas"

          # Optional: Delete the deployment entirely
          # kubectl delete deployment app-blue -n $NAMESPACE --ignore-not-found

      # --------------------------
      # DEPLOYMENT SUCCESS SUMMARY
      # --------------------------
      - name: Deployment success summary
        if: success()
        run: |
          echo "========================================"
          echo "ðŸš€ DEPLOYMENT SUCCESSFUL!"
          echo "========================================"
          echo "âœ“ GREEN version is now live"
          echo "âœ“ Service is routing to GREEN pods"
          echo "âœ“ BLUE version has been scaled down"
          echo ""
          echo "Deployment Details:"
          echo "-------------------"
          echo "Namespace: $NAMESPACE"
          echo "App: $APP_NAME"
          echo "Active Version: $GREEN_LABEL"
          echo "Image Tag: ${{ github.sha }}"
          echo ""
          echo "Current Status:"
          echo "---------------"
          kubectl get deployments -n $NAMESPACE
          echo ""
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME
          echo ""
          kubectl get service app-service -n $NAMESPACE
          echo "========================================"

      # =====================================================================
      # AUTO-ROLLBACK if any step above failed
      # =====================================================================
      - name: AUTO-ROLLBACK to BLUE
        if: failure()
        run: |
          echo "========================================"
          echo "âš ï¸  DEPLOYMENT FAILED - INITIATING ROLLBACK"
          echo "========================================"

          # Record failure
          echo "Failure detected at: $(date -u +'%Y-%m-%dT%H:%M:%SZ')"

          echo ""
          echo "âž¡ Switching service back to BLUE..."
          kubectl patch service app-service -n $NAMESPACE \
            -p '{"spec":{"selector":{"version":"blue"}}}' || \
            echo "Warning: Could not patch service (might not exist)"

          echo ""
          echo "âž¡ Scaling GREEN deployment to 0..."
          kubectl scale deployment app-green --replicas=0 -n $NAMESPACE --ignore-not-found || true

          echo ""
          echo "âž¡ Ensuring BLUE is running..."
          # Check if blue deployment exists
          if ! kubectl get deployment app-blue -n $NAMESPACE &>/dev/null; then
            echo "BLUE deployment doesn't exist, cannot rollback"
            exit 1
          fi

          # Scale blue back up
          kubectl scale deployment app-blue --replicas=2 -n $NAMESPACE

          echo ""
          echo "âž¡ Waiting for BLUE to be ready..."
          kubectl rollout status deployment/app-blue \
            --namespace=$NAMESPACE \
            --timeout=120s || \
            echo "Warning: BLUE rollout status check failed"

          echo ""
          echo "=== Current Status After Rollback ==="
          kubectl get deployments -n $NAMESPACE
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME

          echo ""
          echo "========================================"
          echo "âœ… Rollback completed! Service is back on BLUE version"
          echo "========================================"

          # Exit with failure to mark the workflow as failed
          exit 1

      # --------------------------
      # FINAL VERIFICATION
      # --------------------------
      - name: Final verification
        if: success()
        run: |
          echo "Performing final verification..."

          # Verify all pods are healthy
          kubectl get pods -n $NAMESPACE -l app=$APP_NAME,version=$GREEN_LABEL \
            --field-selector=status.phase=Running | grep -v "No resources" || {
            echo "ERROR: No GREEN pods running"
            exit 1
          }

          # Verify deployment is ready
          kubectl get deployment app-green -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' | grep -q "^[1-9]" || {
            echo "ERROR: GREEN deployment has no ready replicas"
            exit 1
          }

          echo "âœ… Final verification passed!"